"""
실시간 가격 데이터 수집 시스템
- 주식, 암호화폐, 환율 실시간 가격 지원
- 에러 처리 및 재시도 로직 포함
- 웹소켓 및 REST API 지원
"""

import asyncio
import aiohttp
import json
import time
from datetime import datetime
from typing import Dict, List, Optional, Any, Callable
from enum import Enum
import logging
from dataclasses import dataclass
from collections import deque
import threading

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class AssetType(Enum):
    """지원하는 자산 타입"""
    STOCK = "stock"
    CRYPTO = "crypto"
    FOREX = "forex"
    COMMODITY = "commodity"


@dataclass
class PriceData:
    """가격 데이터 구조체"""
    symbol: str
    price: float
    timestamp: datetime
    volume: Optional[float] = None
    bid: Optional[float] = None
    ask: Optional[float] = None
    change_24h: Optional[float] = None
    change_percent_24h: Optional[float] = None
    high_24h: Optional[float] = None
    low_24h: Optional[float] = None
    market_cap: Optional[float] = None
    
    def to_dict(self) -> Dict:
        """딕셔너리로 변환"""
        return {
            'symbol': self.symbol,
            'price': self.price,
            'timestamp': self.timestamp.isoformat(),
            'volume': self.volume,
            'bid': self.bid,
            'ask': self.ask,
            'change_24h': self.change_24h,
            'change_percent_24h': self.change_percent_24h,
            'high_24h': self.high_24h,
            'low_24h': self.low_24h,
            'market_cap': self.market_cap
        }


class PriceDataSource:
    """가격 데이터 소스 기본 클래스"""
    
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
        self.session: Optional[aiohttp.ClientSession] = None
        self.is_connected = False
        
    async def connect(self):
        """연결 초기화"""
        if not self.session:
            self.session = aiohttp.ClientSession()
        self.is_connected = True
        logger.info(f"{self.__class__.__name__} connected")
        
    async def disconnect(self):
        """연결 종료"""
        if self.session:
            await self.session.close()
        self.is_connected = False
        logger.info(f"{self.__class__.__name__} disconnected")
        
    async def get_price(self, symbol: str) -> Optional[PriceData]:
        """가격 데이터 가져오기 (구현 필요)"""
        raise NotImplementedError
        
    async def get_multiple_prices(self, symbols: List[str]) -> Dict[str, PriceData]:
        """여러 심볼의 가격 데이터 가져오기"""
        results = {}
        tasks = [self.get_price(symbol) for symbol in symbols]
        prices = await asyncio.gather(*tasks, return_exceptions=True)
        
        for symbol, price in zip(symbols, prices):
            if not isinstance(price, Exception) and price:
                results[symbol] = price
            else:
                logger.error(f"Failed to get price for {symbol}: {price}")
                
        return results


class CryptoDataSource(PriceDataSource):
    """암호화폐 가격 데이터 소스 (Binance API)"""
    
    BASE_URL = "https://api.binance.com/api/v3"
    
    async def get_price(self, symbol: str) -> Optional[PriceData]:
        """Binance에서 암호화폐 가격 가져오기"""
        try:
            # 24시간 티커 정보
            url = f"{self.BASE_URL}/ticker/24hr"
            params = {'symbol': symbol.upper()}
            
            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    return PriceData(
                        symbol=symbol,
                        price=float(data['lastPrice']),
                        timestamp=datetime.now(),
                        volume=float(data['volume']),
                        bid=float(data['bidPrice']),
                        ask=float(data['askPrice']),
                        change_24h=float(data['priceChange']),
                        change_percent_24h=float(data['priceChangePercent']),
                        high_24h=float(data['highPrice']),
                        low_24h=float(data['lowPrice'])
                    )
                else:
                    logger.error(f"Failed to fetch {symbol}: HTTP {response.status}")
                    return None
                    
        except Exception as e:
            logger.error(f"Error fetching crypto price for {symbol}: {e}")
            return None


class ForexDataSource(PriceDataSource):
    """외환 가격 데이터 소스 (Exchange Rates API)"""
    
    BASE_URL = "https://api.exchangerate-api.com/v4/latest"
    
    async def get_price(self, symbol: str) -> Optional[PriceData]:
        """환율 가져오기 (예: USD/EUR)"""
        try:
            if '/' in symbol:
                base, target = symbol.upper().split('/')
            else:
                logger.error(f"Invalid forex symbol format: {symbol}")
                return None
                
            url = f"{self.BASE_URL}/{base}"
            
            async with self.session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    if target in data['rates']:
                        return PriceData(
                            symbol=symbol,
                            price=data['rates'][target],
                            timestamp=datetime.now()
                        )
                    else:
                        logger.error(f"Target currency {target} not found")
                        return None
                else:
                    logger.error(f"Failed to fetch {symbol}: HTTP {response.status}")
                    return None
                    
        except Exception as e:
            logger.error(f"Error fetching forex rate for {symbol}: {e}")
            return None


class StockDataSource(PriceDataSource):
    """주식 가격 데이터 소스 (Yahoo Finance - yfinance 대체)"""
    
    BASE_URL = "https://query1.finance.yahoo.com/v8/finance/chart"
    
    async def get_price(self, symbol: str) -> Optional[PriceData]:
        """Yahoo Finance에서 주식 가격 가져오기"""
        try:
            url = f"{self.BASE_URL}/{symbol.upper()}"
            
            async with self.session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    result = data['chart']['result'][0]
                    meta = result['meta']
                    
                    return PriceData(
                        symbol=symbol,
                        price=meta['regularMarketPrice'],
                        timestamp=datetime.fromtimestamp(meta['regularMarketTime']),
                        volume=meta.get('regularMarketVolume'),
                        high_24h=meta.get('regularMarketDayHigh'),
                        low_24h=meta.get('regularMarketDayLow'),
                        change_24h=meta['regularMarketPrice'] - meta['previousClose'],
                        change_percent_24h=((meta['regularMarketPrice'] - meta['previousClose']) / meta['previousClose']) * 100
                    )
                else:
                    logger.error(f"Failed to fetch {symbol}: HTTP {response.status}")
                    return None
                    
        except Exception as e:
            logger.error(f"Error fetching stock price for {symbol}: {e}")
            return None


class RealtimePriceFetcher:
    """실시간 가격 데이터 수집기 메인 클래스"""
    
    def __init__(self):
        self.sources: Dict[AssetType, PriceDataSource] = {}
        self.price_cache: Dict[str, deque] = {}  # 가격 히스토리 저장
        self.cache_size = 100  # 각 심볼당 저장할 가격 데이터 수
        self.callbacks: Dict[str, List[Callable]] = {}  # 가격 업데이트 콜백
        self.is_running = False
        self.update_intervals: Dict[str, float] = {}  # 심볼별 업데이트 주기
        
    def register_source(self, asset_type: AssetType, source: PriceDataSource):
        """데이터 소스 등록"""
        self.sources[asset_type] = source
        logger.info(f"Registered {asset_type.value} data source")
        
    async def initialize(self):
        """모든 데이터 소스 초기화"""
        for asset_type, source in self.sources.items():
            await source.connect()
            
    async def shutdown(self):
        """모든 데이터 소스 종료"""
        self.is_running = False
        for source in self.sources.values():
            await source.disconnect()
            
    def add_callback(self, symbol: str, callback: Callable):
        """가격 업데이트 콜백 등록"""
        if symbol not in self.callbacks:
            self.callbacks[symbol] = []
        self.callbacks[symbol].append(callback)
        
    async def _notify_callbacks(self, symbol: str, price_data: PriceData):
        """등록된 콜백 실행"""
        if symbol in self.callbacks:
            for callback in self.callbacks[symbol]:
                try:
                    if asyncio.iscoroutinefunction(callback):
                        await callback(price_data)
                    else:
                        callback(price_data)
                except Exception as e:
                    logger.error(f"Error in callback for {symbol}: {e}")
                    
    def _update_cache(self, symbol: str, price_data: PriceData):
        """가격 캐시 업데이트"""
        if symbol not in self.price_cache:
            self.price_cache[symbol] = deque(maxlen=self.cache_size)
        self.price_cache[symbol].append(price_data)
        
    def get_latest_price(self, symbol: str) -> Optional[PriceData]:
        """최신 가격 데이터 가져오기"""
        if symbol in self.price_cache and self.price_cache[symbol]:
            return self.price_cache[symbol][-1]
        return None
        
    def get_price_history(self, symbol: str, limit: int = 50) -> List[PriceData]:
        """가격 히스토리 가져오기"""
        if symbol in self.price_cache:
            return list(self.price_cache[symbol])[-limit:]
        return []
        
    async def fetch_price(self, symbol: str, asset_type: AssetType) -> Optional[PriceData]:
        """단일 가격 데이터 가져오기"""
        if asset_type not in self.sources:
            logger.error(f"No source registered for {asset_type.value}")
            return None
            
        source = self.sources[asset_type]
        price_data = await source.get_price(symbol)
        
        if price_data:
            self._update_cache(symbol, price_data)
            await self._notify_callbacks(symbol, price_data)
            
        return price_data
        
    async def start_monitoring(self, symbols: Dict[AssetType, List[str]], 
                              update_interval: float = 5.0):
        """실시간 모니터링 시작"""
        self.is_running = True
        
        logger.info(f"Starting real-time monitoring with {update_interval}s interval")
        
        while self.is_running:
            tasks = []
            
            for asset_type, symbol_list in symbols.items():
                if asset_type in self.sources:
                    for symbol in symbol_list:
                        # 심볼별 업데이트 주기 확인
                        interval = self.update_intervals.get(symbol, update_interval)
                        
                        # 마지막 업데이트 시간 확인
                        latest = self.get_latest_price(symbol)
                        if latest:
                            time_diff = (datetime.now() - latest.timestamp).total_seconds()
                            if time_diff < interval:
                                continue
                                
                        tasks.append(self.fetch_price(symbol, asset_type))
                        
            if tasks:
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                # 에러 로깅
                for result in results:
                    if isinstance(result, Exception):
                        logger.error(f"Error during monitoring: {result}")
                        
            await asyncio.sleep(1)  # 짧은 대기 시간
            
    def set_update_interval(self, symbol: str, interval: float):
        """특정 심볼의 업데이트 주기 설정"""
        self.update_intervals[symbol] = interval
        
    async def get_multiple_prices_async(self, symbols_map: Dict[AssetType, List[str]]) -> Dict[str, PriceData]:
        """여러 심볼의 가격을 비동기로 가져오기"""
        all_results = {}
        
        for asset_type, symbols in symbols_map.items():
            if asset_type in self.sources:
                source = self.sources[asset_type]
                results = await source.get_multiple_prices(symbols)
                all_results.update(results)
                
        return all_results


class PriceAlertSystem:
    """가격 알림 시스템"""
    
    def __init__(self, fetcher: RealtimePriceFetcher):
        self.fetcher = fetcher
        self.alerts: List[Dict] = []
        
    def add_price_alert(self, symbol: str, target_price: float, 
                        condition: str = 'above', callback: Optional[Callable] = None):
        """가격 알림 추가"""
        alert = {
            'symbol': symbol,
            'target_price': target_price,
            'condition': condition,  # 'above', 'below', 'equals'
            'callback': callback,
            'triggered': False,
            'created_at': datetime.now()
        }
        self.alerts.append(alert)
        
        # 가격 체크 콜백 등록
        self.fetcher.add_callback(symbol, lambda price: self._check_alert(alert, price))
        
    async def _check_alert(self, alert: Dict, price_data: PriceData):
        """알림 조건 체크"""
        if alert['triggered']:
            return
            
        triggered = False
        current_price = price_data.price
        
        if alert['condition'] == 'above' and current_price > alert['target_price']:
            triggered = True
        elif alert['condition'] == 'below' and current_price < alert['target_price']:
            triggered = True
        elif alert['condition'] == 'equals' and abs(current_price - alert['target_price']) < 0.01:
            triggered = True
            
        if triggered:
            alert['triggered'] = True
            logger.info(f"Price alert triggered for {alert['symbol']}: {current_price} {alert['condition']} {alert['target_price']}")
            
            if alert['callback']:
                if asyncio.iscoroutinefunction(alert['callback']):
                    await alert['callback'](alert, price_data)
                else:
                    alert['callback'](alert, price_data)


# 사용 예제
async def main_example():
    """실시간 가격 데이터 수집 예제"""
    
    # 가격 수집기 초기화
    fetcher = RealtimePriceFetcher()
    
    # 데이터 소스 등록
    fetcher.register_source(AssetType.CRYPTO, CryptoDataSource())
    fetcher.register_source(AssetType.FOREX, ForexDataSource())
    fetcher.register_source(AssetType.STOCK, StockDataSource())
    
    # 초기화
    await fetcher.initialize()
    
    # 가격 업데이트 콜백 예제
    def price_update_callback(price_data: PriceData):
        print(f"[UPDATE] {price_data.symbol}: ${price_data.price:.2f} at {price_data.timestamp}")
    
    # 콜백 등록
    fetcher.add_callback("BTCUSDT", price_update_callback)
    fetcher.add_callback("AAPL", price_update_callback)
    
    # 알림 시스템 설정
    alert_system = PriceAlertSystem(fetcher)
    
    def alert_callback(alert, price_data):
        print(f"[ALERT] {alert['symbol']} reached {alert['target_price']}! Current: ${price_data.price:.2f}")
    
    # 가격 알림 추가
    alert_system.add_price_alert("BTCUSDT", 50000, "above", alert_callback)
    alert_system.add_price_alert("AAPL", 150, "below", alert_callback)
    
    # 모니터링할 심볼 설정
    symbols_to_monitor = {
        AssetType.CRYPTO: ["BTCUSDT", "ETHUSDT"],
        AssetType.STOCK: ["AAPL", "GOOGL"],
        AssetType.FOREX: ["USD/EUR", "USD/KRW"]
    }
    
    # 특정 심볼의 업데이트 주기 설정 (빠른 업데이트)
    fetcher.set_update_interval("BTCUSDT", 2.0)  # 2초마다
    
    try:
        # 실시간 모니터링 시작 (백그라운드)
        monitor_task = asyncio.create_task(
            fetcher.start_monitoring(symbols_to_monitor, update_interval=5.0)
        )
        
        # 10초 동안 실행
        await asyncio.sleep(10)
        
        # 가격 히스토리 출력
        print("\n=== Price History ===")
        for symbol in ["BTCUSDT", "AAPL"]:
            history = fetcher.get_price_history(symbol, limit=5)
            if history:
                print(f"\n{symbol}:")
                for price_data in history:
                    print(f"  ${price_data.price:.2f} at {price_data.timestamp}")
        
    finally:
        # 종료
        await fetcher.shutdown()


if __name__ == "__main__":
    # 실행
    asyncio.run(main_example())
